{"version":3,"file":"main.669692f7e2dcfce1eba6.bundle.js","sources":["webpack:///./src/components/helpers.js"],"sourcesContent":["import { Component, h } from 'preact';\nimport { Livechat } from '../api';\n\n\nexport function flatMap(arr, mapFunc) {\n\tconst result = [];\n\tfor (const [index, elem] of arr.entries()) {\n\t\tconst x = mapFunc(elem, index, arr);\n\t\t// We allow mapFunc() to return non-Arrays\n\t\tif (Array.isArray(x)) {\n\t\t\tresult.push(...x);\n\t\t} else {\n\t\t\tresult.push(x);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport const createClassName = (styles, elementName, modifiers = {}, classes = []) => [\n\tstyles[elementName],\n\t...(flatMap(Object.entries(modifiers), ([modifierKey, modifierValue]) => [\n\t\tmodifierValue && styles[`${ elementName }--${ modifierKey }`],\n\t\ttypeof modifierValue !== 'boolean' && styles[`${ elementName }--${ modifierKey }-${ modifierValue }`],\n\t]).filter((className) => !!className)), ...classes].join(' ');\n\nexport async function asyncForEach(array, callback) {\n\tfor (let index = 0; index < array.length; index++) {\n\t\tawait callback(array[index], index, array);\n\t}\n}\n\nexport async function asyncEvery(array, callback) {\n\tfor (let index = 0; index < array.length; index++) {\n\t\tif (!await callback(array[index], index, array)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nexport const debounce = (func, delay) => {\n\tlet inDebounce;\n\n\tfunction f(...args) {\n\t\tconst context = this;\n\t\tclearTimeout(inDebounce);\n\t\tinDebounce = setTimeout(() => func.apply(context, args), delay);\n\t\treturn context;\n\t}\n\n\tf.stop = () => clearTimeout(inDebounce);\n\n\treturn f;\n};\n\nexport const throttle = (func, limit) => {\n\tlet inThrottle;\n\treturn function(...args) {\n\t\tconst context = this;\n\t\tif (!inThrottle) {\n\t\t\tfunc.apply(context, args);\n\t\t\tinThrottle = true;\n\t\t\tsetTimeout(() => inThrottle = false, limit);\n\t\t}\n\t};\n};\n\nexport function sort(array, value) {\n\tlet min = 0;\n\tlet max = array.length - 1;\n\n\twhile (min <= max) {\n\t\tconst guess = Math.floor((min + max) / 2);\n\t\tconst { ts } = array[guess];\n\t\tif (ts < value) {\n\t\t\tmin = guess + 1;\n\t\t} else if (ts > array[guess + 1]) {\n\t\t\treturn guess;\n\t\t} else {\n\t\t\tmax = guess - 1;\n\t\t}\n\t}\n\n\treturn array.length > 0 ? array.length : 0;\n}\n\nexport const insert = (array, el) => (array.splice(sort(array, el.ts), 0, el), array);\n\nexport const setCookies = (rid, token) => {\n\tdocument.cookie = `rc_rid=${ rid }; path=/`;\n\tdocument.cookie = `rc_token=${ token }; path=/`;\n\tdocument.cookie = 'rc_room_type=l; path=/';\n};\n\nexport const createToken = () => (Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15));\n\nexport const getAvatarUrl = (username) => (username ? `${ Livechat.client.host }/avatar/${ username }` : null);\n\nexport const msgTypesNotDisplayed = ['livechat_video_call', 'livechat_navigation_history', 'au'];\n\nexport const renderMessage = (message = {}) => (message.t !== 'command' && !msgTypesNotDisplayed.includes(message.t));\n\nexport const getAttachmentsUrl = (attachments) => attachments && attachments.map((attachment) => {\n\tconst assetUrl = attachment.image_url || attachment.video_url || attachment.audio_url || attachment.title_link;\n\treturn { ...attachment, attachment_url: `${ Livechat.client.host }${ assetUrl }` };\n});\n\nexport const normalizeDOMRect = (({ left, top, right, bottom }) => ({ left, top, right, bottom }));\n\n\nexport const visibility = (() => {\n\tif (typeof document.hidden !== 'undefined') {\n\t\treturn {\n\t\t\tget hidden() {\n\t\t\t\treturn document.hidden;\n\t\t\t},\n\t\t\taddListener: (f) => document.addEventListener('visibilitychange', f, false),\n\t\t\tremoveListener: (f) => document.removeEventListener('visibilitychange', f, false),\n\t\t};\n\t}\n\n\tif (typeof document.msHidden !== 'undefined') {\n\t\treturn {\n\t\t\tget hidden() {\n\t\t\t\treturn document.msHidden;\n\t\t\t},\n\t\t\taddListener: (f) => document.addEventListener('msvisibilitychange', f, false),\n\t\t\tremoveListener: (f) => document.removeEventListener('msvisibilitychange', f, false),\n\t\t};\n\t}\n\n\tif (typeof document.webkitHidden !== 'undefined') {\n\t\treturn {\n\t\t\tget hidden() {\n\t\t\t\treturn document.webkitHidden;\n\t\t\t},\n\t\t\taddListener: (f) => document.addEventListener('webkitvisibilitychange', f, false),\n\t\t\tremoveListener: (f) => document.removeEventListener('webkitvisibilitychange', f, false),\n\t\t};\n\t}\n\n\treturn {\n\t\thidden: true,\n\t\taddListener: () => {},\n\t\tremoveListener: () => {},\n\t};\n})();\n\n\nexport const memo = (component) => class MemoizedComponent extends Component {\n\tshouldComponentUpdate(nextProps) {\n\t\tconst { props } = this;\n\n\t\tfor (const key in props) {\n\t\t\tif (key === 'children') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (props[key] !== nextProps[key]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in nextProps) {\n\t\t\tif (key === 'children') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(key in props)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\trender(props) {\n\t\treturn h(component, props);\n\t}\n};\n"],"mappings":"AAIA","sourceRoot":""}